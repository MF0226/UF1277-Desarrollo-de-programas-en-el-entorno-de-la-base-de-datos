SET SERVEROUTPUT ON

CREATE OR REPLACE PROCEDURE tabla_a_json (
    p_tabla IN VARCHAR2
)
AS
    v_sql           VARCHAR2(32767);
    -- Handle del cursor dinámico de DBMS_SQL.
    v_cursor        INTEGER;
    v_col_count     INTEGER;
    v_ret           INTEGER;

    -- Tipo de datos para almacenar los metadatos de las columnas.
    desc_tab        DBMS_SQL.DESC_TAB;
    -- Variable temporal para almacenar el valor de cada columna (se usa VARCHAR2).
    v_value         VARCHAR2(4000);
    -- Variable para construir la salida JSON.
    v_json          CLOB;
BEGIN
    -- NOTA DIDÁCTICA: Este procedimiento utiliza DBMS_SQL para la introspección (DESCRIBE_COLUMNS).
    -- Esta técnica es útil para el manejo avanzado de metadatos,
    -- pero para la generación de JSON puro, la alternativa moderna son las funciones SQL nativas
    -- (JSON_OBJECT y JSON_ARRAYAGG) junto con EXECUTE IMMEDIATE, que son más rápidas y simples.

    -------------------------------------------------------------------
    -- 1. Validar existencia de la tabla
    -------------------------------------------------------------------
    DECLARE
        v_dummy VARCHAR2(1);
    BEGIN
        -- Consulta al diccionario para asegurar que la tabla existe.
        SELECT 'X'
        INTO v_dummy
        FROM USER_TABLES
        WHERE TABLE_NAME = UPPER(p_tabla);
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE_APPLICATION_ERROR(
                -20001,
                'La tabla "' || p_tabla || '" no existe en el esquema.'
            );
    END;

    -------------------------------------------------------------------
    -- 2. Construir SELECT dinámico con todas las columnas
    -------------------------------------------------------------------
    SELECT LISTAGG(column_name, ', ') WITHIN GROUP (ORDER BY column_id)
    INTO v_sql
    FROM USER_TAB_COLUMNS
    WHERE TABLE_NAME = UPPER(p_tabla);

    -- Uso de DBMS_ASSERT para garantizar la seguridad del nombre de la tabla.
    v_sql := 'SELECT ' || v_sql ||
             ' FROM ' || DBMS_ASSERT.SIMPLE_SQL_NAME(UPPER(p_tabla));

    -------------------------------------------------------------------
    -- 3. Crear cursor dinámico (DBMS_SQL)
    -------------------------------------------------------------------
    -- El manejo con DBMS_SQL requiere múltiples llamadas secuenciales para abrir y analizar.
    v_cursor := DBMS_SQL.OPEN_CURSOR;
    DBMS_SQL.PARSE(v_cursor, v_sql, DBMS_SQL.NATIVE);

    -------------------------------------------------------------------
    -- 4. Obtener metadatos de columnas
    -------------------------------------------------------------------
    -- DESCRIBE_COLUMNS: Paso necesario de DBMS_SQL para conocer la estructura de la consulta
    -- antes de poder extraer los datos.
    DBMS_SQL.DESCRIBE_COLUMNS(v_cursor, v_col_count, desc_tab);

    FOR i IN 1 .. v_col_count LOOP
        -- DEFINE_COLUMN: Se debe asignar explícitamente una variable de PL/SQL (v_value)
        -- para cada columna antes de realizar el FETCH.
        DBMS_SQL.DEFINE_COLUMN(v_cursor, i, v_value, 4000);
    END LOOP;

    -------------------------------------------------------------------
    -- 5. Ejecutar SELECT dinámico
    -------------------------------------------------------------------
    v_ret := DBMS_SQL.EXECUTE(v_cursor);

    -------------------------------------------------------------------
    -- 6. Recuperar filas y generar JSON para cada una
    -------------------------------------------------------------------
    -- FETCH_ROWS: Bucle para extraer los datos fila por fila.
    WHILE DBMS_SQL.FETCH_ROWS(v_cursor) > 0 LOOP
        v_json := '{'; -- Inicio del objeto JSON para la fila

        FOR i IN 1 .. v_col_count LOOP
            -- COLUMN_VALUE: Recupera el valor de la columna 'i' en la variable v_value.
            DBMS_SQL.COLUMN_VALUE(v_cursor, i, v_value);

            -- Generación MANUAL de JSON: Concatenación de cadenas, comillas y manejo de NULL.
            -- Esto se hace automáticamente con las funciones nativas (JSON_OBJECT) en el enfoque moderno.
            v_json := v_json ||
                      '"' || desc_tab(i).col_name || '": ' ||
                      CASE WHEN v_value IS NULL THEN 'null'
                           ELSE '"' || REPLACE(v_value, '"', '\"') || '"'
                      END;

            IF i < v_col_count THEN
                v_json := v_json || ', ';
            END IF;
        END LOOP;

        v_json := v_json || '}';

        DBMS_OUTPUT.PUT_LINE(v_json);
    END LOOP;

    -------------------------------------------------------------------
    -- 7. Cerrar cursor
    -------------------------------------------------------------------
    DBMS_SQL.CLOSE_CURSOR(v_cursor);

EXCEPTION
    WHEN OTHERS THEN
        -- Gestión de errores: siempre asegurar el cierre del cursor de DBMS_SQL si ocurrió un error.
        IF DBMS_SQL.IS_OPEN(v_cursor) THEN
            DBMS_SQL.CLOSE_CURSOR(v_cursor);
        END IF;
        RAISE;
END tabla_a_json;
/

-- Ejemplo de uso
EXECUTE tabla_a_json('REGIONS');

-- La versión anterior tiene caracter didáctico, ya que existen funciones de JSON que simplican el código
CREATE OR REPLACE PROCEDURE tabla_a_json_moderna (
    p_tabla IN VARCHAR2
)
AS
    v_columnas_json VARCHAR2(32767);
    v_sql           CLOB;
    v_json_out      CLOB;
    v_tabla_segura  VARCHAR2(128);
BEGIN
    -- 1. Seguridad y Validación:
    -- Asegurar que el nombre de la tabla sea seguro contra inyección.
    v_tabla_segura := DBMS_ASSERT.SIMPLE_SQL_NAME(UPPER(p_tabla));

    -- 2. Construcción Dinámica de Claves JSON:
    -- LISTAGG construye dinámicamente la lista de pares clave-valor (JSON_OBJECT)
    -- usando las funciones nativas JSON de Oracle.
    -- El resultado es una cadena como: '"COL1" VALUE COL1, "COL2" VALUE COL2, ...'
    SELECT LISTAGG(
               '"' || column_name || '" VALUE ' || column_name,
               ', '
           ) WITHIN GROUP (ORDER BY column_id)
    INTO v_columnas_json
    FROM USER_TAB_COLUMNS
    WHERE TABLE_NAME = v_tabla_segura;

    -- Si no hay columnas (tabla vacía o no existe), LISTAGG devuelve NULL.
    IF v_columnas_json IS NULL THEN
        RAISE_APPLICATION_ERROR(
            -20001,
            'La tabla "' || p_tabla || '" no existe o no tiene columnas.'
        );
    END IF;

    -- 3. Construcción de la Sentencia SQL Final:
    -- Se usa JSON_OBJECT para cada fila y JSON_ARRAYAGG para encapsular todas las filas.
    v_sql := 'SELECT JSON_ARRAYAGG(
                  JSON_OBJECT(' || v_columnas_json || ' ABSENT ON NULL)
                  RETURNING CLOB
              )
              FROM ' || v_tabla_segura;

    -- 4. Ejecución Dinámica y Recuperación del CLOB:
    -- Se utiliza EXECUTE IMMEDIATE con INTO, ya que la consulta devuelve exactamente una fila (un CLOB).
    EXECUTE IMMEDIATE v_sql INTO v_json_out;

    -- 5. Salida del Resultado:
    DBMS_OUTPUT.PUT_LINE(v_json_out);

END tabla_a_json_moderna;
/

-- Ejemplo de uso
EXECUTE tabla_a_json_moderna('REGIONS');
